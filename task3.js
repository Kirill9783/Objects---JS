const car = {
    name: 'Haval',
    hp: 198
}

//1 способ
function createCar(object) {
    const baseCar = {
        wheels: 4,
        doors: 4,
        isStarted: false
    }
    return Object.assign(object, baseCar);
}
console.log(createCar(car));

console.log('------------------------------------------------');

//2 способ
function createCar2(object) {
    const baseCar = {
        wheels: 4,
        doors: 4,
        isStarted: false
    }
    return {
        ...object,
        ...baseCar
    };
}
console.log(createCar2(car));

/*
Второй способ предпочтительнее, потому что:

Не мутирует исходный объект

В первом способе Object.assign(object, baseCar); изменяет (мутирует) переданный объект object. Это может привести к нежелательным побочным эффектам, если тот же объект используется где-то ещё в коде.
Во втором способе создаётся новый объект { ...object, ...baseCar }, а исходный объект остаётся неизменным, что делает код более безопасным и предсказуемым.
Явно создаётся новый объект

В первом способе возвращается тот же объект, который был передан в функцию, но с добавленными свойствами. Это не всегда очевидно и может привести к трудноотлавливаемым ошибкам.
Во втором способе создаётся новый объект, объединяющий свойства object и baseCar. Это соответствует принципу иммутабельности, который часто используется в современном программировании (например, в React и Redux).
Более читаемый и предсказуемый код

Использование оператора расширения (...) делает код более компактным и легко читаемым.
Код с Object.assign() выглядит громоздким и требует явного указания целевого объекта.
Вывод: второй способ предпочтительнее, так как он создаёт новый объект вместо изменения существующего, что делает код более безопасным, читаемым и предсказуемым.
 */

